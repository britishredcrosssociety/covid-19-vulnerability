#' Add numbers only if at least one of them isn't zero or NA
#' If both numbers are zero or NA, return zero
#'
#' @param x First number
#' @param y Second number
#'
#' @examples
#' 1 %++% 1  # == 2
#' 1 %++% NA # == 1
`%++%` = function(x, y) {
  if ( (is.na(x) | x == 0) & (is.na(y) | y == 0) ) {
    0
  } else {
    ifelse(is.na(x), 0, x) + ifelse(is.na(y), 0, y)
  }
}

#' Calculate risk quantiles
#' 
#' @param risk.col The data to quantise
#' @param quants Number of quantiles (default: 5)
#' @param highest.quantile.is.worst Should a risk score of 1 represent the highest/worst number in the data (FALSE) or the lowest/best (FALSE)?
#' @param style Method to use for calculating quantiles (passed to classIntervals; default: Fisher). One of "fixed", "sd", "equal", "pretty", "quantile", "kmeans", "hclust", "bclust", "fisher", "jenks" or "dpih"
#' @param samp_prop The proportion of samples to use, if slicing using "fisher" or "jenks" (passed to classIntervals; default: 100%)
#' @return A vector containing the risk quantiles
#'
calc_risk_quantiles = function(risk.col, quants = 5, highest.quantile.is.worst = TRUE, style = "fisher", samp_prop = 1) {
  if (length(unique(risk.col)) > 1) {  # only calculate quintiles if there are more unique values than quantiles
    
    # calculate the quantile breaks
    q_breaks = classInt::classIntervals(risk.col, quants, style = style, samp_prop = samp_prop, largeN = length(risk.col))
    
    q = as.integer(cut(risk.col, breaks = q_breaks$brks, include.lowest = T))  # create a column with the risk quantiles as a number (e.g. from 1 to 5, if using quintiles)
  
    if (!highest.quantile.is.worst) {
      max_quant = max(q, na.rm = TRUE)  # get the max. quantile in the dataset (won't always be equal to `quants`, e.g. if nrows(d) < quants)
      q = (max_quant + 1) - q  # reverse the quantile scoring so 1 = highest risk
    }
    
    q  # return the quantiles
    
  } else {
    1
  }
}


#########################################################################################################
## functions for calculating the vulnerability index, in the style of the Index of Multiple Deprivation
##

#' Transform data to an exponential distribution
#' using the exponential transformation function listed in Welsh IMD's tech report - see Appendix A: https://gov.wales/sites/default/files/statistics-and-research/2020-02/welsh-index-multiple-deprivation-2019-technical-report.pdf
#'  
#'  @param x The data to transform
#'  
exp_transform = function(x) -23 * log(1 - x * (1 -exp(-100/23)))

#' Normalise ranks to a range between 0 and 1
#' 
#' @param x List of ranks
#' 
scale_ranks = function(x) (x - 1) / (length(x) - 1)

#' Rank indicators but put NAs first (i.e. least-worst)
#' @param x Data to rank
#' 
rank2 = function(x) rank(x, na.last = FALSE)

#' Calculate domain scores, ranks and deciles
#' This function will calculate over all numeric variables in a dataframe
#' 
#' @param d Dataframe containing underlying indicators
#' @param domain Name of the vulnerability domain - if not blank, prepend this string to the vulnerability score/rank/decile columns
#' @param rank.indicators Rank the underlying indicators before calculating scores etc.?
#' @param keep.interim.indicators If TRUE, keep the scores and ranks calculated for each underlying indicator (default: FALSE)
#' 
calc_domain_scores = function(d, domain = NULL, rank.indicators = TRUE, keep.interim.indicators = FALSE) {
  if (rank.indicators) {
    d = d %>% 
      mutate_if(is.numeric, list(rank = rank2))  # convert indicators to ranks
  }
  
  d = d %>% 
    # normalise the ranks so they're between 0 and 1
    mutate_at(vars(ends_with("rank")), list(scaled = scale_ranks)) %>% 
    
    # transform to an exponential distribution
    mutate_at(vars(ends_with("_scaled")), exp_transform) %>% 
    
    # combine with equal weights to get domain score
    mutate(`Vulnerability score` = reduce(select(., ends_with("_scaled")), `+`)) %>%   # source: https://stackoverflow.com/a/54527609
    
    # calculate domain ranks and deciles
    mutate(`Vulnerability rank` = rank(`Vulnerability score`)) %>% 
    mutate(`Vulnerability decile` = calc_risk_quantiles(`Vulnerability rank`, quants = 10))
  
  if (is.character(domain))
    names(d)[ grepl("^Vulnerability", names(d)) ] = paste(domain, grep("^Vulnerability", names(d), value = T), sep = " ")
  
  if (!keep.interim.indicators)
    # keep only original indicators and domain vulnerability score/rank/decile
    d = d %>% select(-ends_with("_rank"), -ends_with("_scaled"))
  
  d
}
