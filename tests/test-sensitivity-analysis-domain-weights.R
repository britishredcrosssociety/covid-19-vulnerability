# This is a test file to experiment with sensitivity analysis for varying domain weights.
# This file has been written to use the "create vulnerability index - MSOA - England.r" file.
# Other files can be exchanged in its place, but the 'Load data' section needs updating
# accordingly.

# ---- Load libraries ----
library(tidyverse)

# ---- Load data ----
# # Source MSOA England file up to line 326, just before the VI is created
# source(textConnection(read_lines("create vulnerability index - MSOA - England.r",
#                                  n_max = 326)))
# 
# # Combine MSOA data ready to be piped into calc_domain_scores function
# msoa_data <- clinical %>%
#   select(MSOA11CD, `Clinical Vulnerability rank`) %>%
#   left_join(health_wellbeing %>% select(MSOA11CD, `Health/Wellbeing Vulnerability rank`),
#             by = "MSOA11CD") %>%
#   left_join(economic %>% select(MSOA11CD, ends_with("Vulnerability rank")),
#             by = "MSOA11CD") %>%
#   left_join(social %>% select(MSOA11CD, `Social Vulnerability rank`),
#             by = "MSOA11CD")

msoa_data <- read_csv("tests/msoa_data.csv")
source("functions.r")

# ---- Weights ----
# Create a tibble of weights to iterate over
# Other ideas: 1. use Dirichlet distrubtion to generate weights: https://cran.r-project.org/web/packages/gtools/index.html
#              2. Just use runif() and divide by sum() e.g., x <- runif(3) then x/sum(x)
# https://stackoverflow.com/questions/11003967/generate-3-random-number-that-sum-to-1-in-r

weights <- crossing(clinical_weight = c(0, .25, .5, .75, 1),
                    health_weight   = c(0, .25, .5, .75, 1),
                    economic_weight = c(0, .25, .5, .75, 1),
                    social_weight   = c(0, .25, .5, .75, 1)) %>% 
  rowwise() %>% 
  filter(sum(c_across(everything())) == 1,
         # removes rows where more than two indicators are varying
         !if_else(sum(c_across(everything()) > 0) > 2, TRUE, FALSE))

# ---- Iterate ----
# Iterate over each row of weighs, inputting weights into calc_domain_scores
# Store result in new column, vi (nested data structure - i.e., one tibble per row)
weighted_vi <- weights %>% 
  mutate(vi = list(calc_domain_scores(d = msoa_data,
                                      rank.indicators = FALSE,
                                      clinical_weight = clinical_weight,
                                      health_weight = health_weight,
                                      economic_weight = economic_weight,
                                      social_weight = social_weight))) %>% 
  ungroup()

# ---- Calculate Assessment Metric ----
# To establish whether the allocated weights have an effect on the VI, create a global
# metric, change_score, that counts the number of regions that have changed decile.
# see: https://assets.publishing.service.gov.uk/government/uploads/system/uploads/attachment_data/file/835115/IoD2019_Statistical_Release.pdf

# Create current baseline tibble (weights all set to .025)
# Calculate difference against each nested row of weighted_vi

# ---- Plot ----
weighted_vi %>%
  unnest(cols = c(vi))

# Facets?